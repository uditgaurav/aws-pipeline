---
name: AWS-Experiment-Pipeline
on:
  workflow_dispatch:
    inputs:
      goExperimentImage:
        default: "litmuschaos/go-runner:ci"
      operatorImage:
        default: "litmuschaos/chaos-operator:ci"
      runnerImage:
        default: "litmuschaos/chaos-runner:ci"
      chaosNamespace:
        default: "default"
      experimentImagePullPolicy:
        default: "Always"
  
jobs:
  # AWS_EC2_Terminate:
  #   runs-on: ubuntu-latest
  #   steps:
    
  #     #Install and configure a k3s cluster
  #     - name: Installing Prerequisites (K3S Cluster)
  #       env: 
  #         KUBECONFIG: /etc/rancher/k3s/k3s.yaml
  #       run: |
  #         curl -sfL https://get.k3s.io | sh -s - --docker --write-kubeconfig-mode 664
  #         kubectl wait node --all --for condition=ready --timeout=90s
  #         mkdir -p $HOME/.kube && cat /etc/rancher/k3s/k3s.yaml > $HOME/.kube/config          
  #         kubectl get nodes
          
  #     - uses: actions/checkout@v2

  #     - uses: actions/setup-go@v2
  #       with:
  #         go-version: '1.14'

  #     - name: Create Kubernetes secret for aws experiment
  #       if: always()
  #       env:
  #         KUBECONFIG: /etc/rancher/k3s/k3s.yaml      
  #       run: |
  #         cat <<EOF | kubectl apply -f -
  #         apiVersion: v1
  #         kind: Secret
  #         metadata:
  #           name: cloud-secret
  #           namespace: default
  #         type: Opaque
  #         stringData:
  #           cloud_config.yml: |-
  #             [default]
  #             aws_access_key_id = ${{ secrets.AWS_ACCESS_KEY_ID }}
  #             aws_secret_access_key = ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         EOF
          
  #     - name: Configure AWS Credentials
  #       if: always()
  #       uses: aws-actions/configure-aws-credentials@v1
  #       with:
  #         aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         # aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }} # if you have/need it
  #         aws-region: us-west-1
          
  #     - name: Creating target EC2 instances
  #       if: always()
  #       run: |
  #         aws ec2 run-instances --image-id ami-0d382e80be7ffdae5 --count 2 --instance-type t2.nano \
  #         --key-name udit-litmus-e2e --security-group-ids sg-06925d6218d07e795 --subnet-id subnet-9c2ba8fa \
  #         --region us-west-1 --tag-specifications 'ResourceType=instance,Tags=[{Key=runNumber,Value=${{ github.run_number }}}]'
          
  #     - name: Get the target instance name
  #       if: always()
  #       run: |
  #         instances=$(aws ec2 describe-instances --filters Name=tag-value,Values=${{ github.run_number }} Name=instance-state-name,Values=pending,running --region us-west-1 --query 'Reservations[*].Instances[*].{Instance:InstanceId}' --output text)
  #         instance_list=($instances)
  #         echo "inst1: ${instance_list[0]} inst2: ${instance_list[1]}"
  #         echo "INSTANCE_ONE=${instance_list[0]}" >> $GITHUB_ENV
  #         echo "INSTANCE_TWO=${instance_list[1]}" >> $GITHUB_ENV
          
  #     - name: Litmus Infra Setup
  #       if: always()
  #       run: make build-litmus
  #       env:
  #         KUBECONFIG: /etc/rancher/k3s/k3s.yaml
  #         OPERATOR_IMAGE: "${{ github.event.inputs.operatorImage }}"
  #         RUNNER_IMAGE: "${{ github.event.inputs.runnerImage }}"


  #     - name: Run EC2 Terminate By ID experiment in serial & parallel mode
  #       if: always()
  #       env:
  #         KUBECONFIG: /etc/rancher/k3s/k3s.yaml
  #         EC2_INSTANCE_ID: "${{ env.INSTANCE_ONE }},${{ env.INSTANCE_TWO }}"
  #         REGION: us-west-1
  #         GO_EXPERIMENT_IMAGE: "${{ github.event.inputs.goExperimentImage }}"
  #         EXPERIMENT_IMAGE_PULL_POLICY: "${{ github.event.inputs.experimentImagePullPolicy }}"
  #         CHAOS_NAMESPACE: "${{ github.event.inputs.chaosNamespace }}"
  #       run: make ec2-terminate-by-id

  #     - name: Run EC2 Terminate By Tag experiment in serial & parallel mode
  #       if: always()
  #       env:
  #         KUBECONFIG: /etc/rancher/k3s/k3s.yaml
  #         EC2_INSTANCE_TAG: "runNumber:${{ github.run_number }}"
  #         REGION: us-west-1
  #         GO_EXPERIMENT_IMAGE: "${{ github.event.inputs.goExperimentImage }}"
  #         EXPERIMENT_IMAGE_PULL_POLICY: "${{ github.event.inputs.experimentImagePullPolicy }}"
  #         CHAOS_NAMESPACE: "${{ github.event.inputs.chaosNamespace }}"
  #       run: make ec2-terminate-by-tag   

  #     - name: Terminate target EC2 instances
  #       if: always()
  #       run: |
  #         aws ec2 terminate-instances --instance-ids ${{ env.INSTANCE_ONE }} ${{ env.INSTANCE_TWO }} --region us-west-1



  AWS_EBS_Loss:
    runs-on: ubuntu-latest
    steps:
    
      #Install and configure a k3s cluster
      - name: Installing Prerequisites (K3S Cluster)
        env: 
          KUBECONFIG: /etc/rancher/k3s/k3s.yaml
        run: |
          curl -sfL https://get.k3s.io | sh -s - --docker --write-kubeconfig-mode 664
          kubectl wait node --all --for condition=ready --timeout=90s
          mkdir -p $HOME/.kube && cat /etc/rancher/k3s/k3s.yaml > $HOME/.kube/config          
          kubectl get nodes
          
      - uses: actions/checkout@v2

      - uses: actions/setup-go@v2
        with:
          go-version: '1.14'

      - name: Create Kubernetes secret for aws experiment
        if: always()
        env:
          KUBECONFIG: /etc/rancher/k3s/k3s.yaml      
        run: |
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: Secret
          metadata:
            name: cloud-secret
            namespace: default
          type: Opaque
          stringData:
            cloud_config.yml: |-
              [default]
              aws_access_key_id = ${{ secrets.AWS_ACCESS_KEY_ID }}
              aws_secret_access_key = ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          EOF
          
      - name: Configure AWS Credentials
        if: always()
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          # aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }} # if you have/need it
          aws-region: us-west-1
          
      - name: Creating EC2 instances
        if: always()
        run: |
          aws ec2 run-instances \
          --image-id ami-0d382e80be7ffdae5 \
          --count 1 \
          --instance-type t2.nano \
          --key-name udit-litmus-e2e \
          --security-group-ids sg-06925d6218d07e795 \
          --subnet-id subnet-9c2ba8fa \
          --placement AvailabilityZone=us-west-1b \
          --region us-west-1 \
          --tag-specifications 'ResourceType=instance,Tags=[{Key=runNumber,Value=${{ github.run_number }}}]'

      - name: Create EBS volumes
        if: always()
        run: |
          aws ec2 create-volume \
          --volume-type gp2 \
          --size 4 \
          --availability-zone us-west-1b \
          --region us-west-1 \
          --tag-specifications 'ResourceType=volume,Tags=[{Key=runNumber,Value=${{ github.run_number }}}]'
          
      - name: Get the ec2 instance id
        if: always()
        run: |
          instances=$(aws ec2 describe-instances --filters Name=tag-value,Values=${{ github.run_number }} Name=instance-state-name,Values=pending,running --region us-west-1 --query 'Reservations[*].Instances[*].{Instance:InstanceId}' --output text)
          instance_list=($instances)
          echo "INSTANCE_ONE=${instance_list[0]}" >> $GITHUB_ENV
          
      - name: Get the EBS volume id
        run: |
          volumes=$(aws ec2 describe-volumes --filters Name=tag-value,Values=${{ github.run_number }} Name=availability-zone,Values=us-west-1b --query "Volumes[*].{ID:VolumeId}" --output text)
          echo "VOLUME_ID=${volumes}" >> $GITHUB_ENV         
          
      - name: Litmus Infra Setup
        if: always()
        run: make build-litmus
        env:
          KUBECONFIG: /etc/rancher/k3s/k3s.yaml
          OPERATOR_IMAGE: "${{ github.event.inputs.operatorImage }}"
          RUNNER_IMAGE: "${{ github.event.inputs.runnerImage }}"

      - name: Attach the target ebs volume to the ec2 instance
        if: always()
        run: aws ec2 attach-volume --volume-id ${{ env.VOLUME_ID }} --instance-id ${{ env.INSTANCE_ONE }} --device /dev/sdf

      - name: Run EBS Loss By ID experiment in serial & parallel mode
        if: always()
        env:
          KUBECONFIG: /etc/rancher/k3s/k3s.yaml
          EBS_VOLUME_ID: "${{ env.VOLUME_ID }}"
          REGION: us-west-1
          GO_EXPERIMENT_IMAGE: "${{ github.event.inputs.goExperimentImage }}"
          EXPERIMENT_IMAGE_PULL_POLICY: "${{ github.event.inputs.experimentImagePullPolicy }}"
          CHAOS_NAMESPACE: "${{ github.event.inputs.chaosNamespace }}"
        run: make ebs-loss-by-id

      - name: Run EBS Loss By Tag experiment in serial & parallel mode
        if: always()
        env:
          KUBECONFIG: /etc/rancher/k3s/k3s.yaml
          EBS_VOLUME_TAG: "runNumber:${{ github.run_number }}"
          REGION: us-west-1
          GO_EXPERIMENT_IMAGE: "${{ github.event.inputs.goExperimentImage }}"
          EXPERIMENT_IMAGE_PULL_POLICY: "${{ github.event.inputs.experimentImagePullPolicy }}"
          CHAOS_NAMESPACE: "${{ github.event.inputs.chaosNamespace }}"
        run: make ebs-loss-by-tag   

      - name: Terminate EC2 instance
        if: always()
        run: |
          aws ec2 terminate-instances --instance-ids ${{ env.INSTANCE_ONE }} --region us-west-1

      - name: Waiting for ec2 instance to get terminate
        if: always()
        run: |
          for i in range {0..30};do
            instance_status=$(aws ec2 describe-instance-status --instance-id i-027c447e08f8f0af3 --query 'InstanceStatuses[*].InstanceState.Name' --output text)
            echo "ec2 instance status is: ${instance_status}"
            if [ -z "$instance_status" ];then
              echo "The ec2 instance is terminated"
              break
            fi
            sleep 3
          done

      - name: Delete EBS Volume
        if: always()
        run: |
          aws ec2 delete-volume --volume-id "${{ env.VOLUME_ID }}" --region us-west-1
